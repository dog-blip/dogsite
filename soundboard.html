<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Soundboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script>
        // Extra iOS zoom prevention
        document.addEventListener('touchmove', function(event) {
            if (event.scale !== 1) {
                event.preventDefault();
            }
        }, { passive: false });

        // Prevent double-tap to zoom on iOS
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function(event) {
          let now = (new Date()).getTime();
          if (now - lastTouchEnd <= 300) {
            event.preventDefault();
          }
          lastTouchEnd = now;
        }, false);
    </script>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 72 72'%3E%3Ctext y='60' font-size='60'%3E%F0%9F%A5%80%3C/text%3E%3C/svg%3E">
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            height: 100vh;
            padding-top: 40px;
        }
        .soundboard-buttons,
        .custom-sounds-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }
        .soundboard-btn {
            font-size: 1rem;
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            background: #ececec;
            cursor: pointer;
            transition: background 0.2s;
        }
        .soundboard-btn:hover {
            background: #d1eaff;
        }
        .controls-row {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 20px;
        }
        form {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 0;
        }
        .remove-btn {
            margin-left: 5px;
            background: #ffb2b2;
            color: #420000;
            padding: 2px 7px;
            border: none;
            border-radius: 5px;
            font-size: 0.8rem;
            cursor: pointer;
        }
        .remove-btn:hover {
            background: #ff5252;
            color: white;
        }
        .section-title {
            width: 100%;
            text-align: center;
            font-weight: bold;
            margin: 18px 0 5px 0;
            font-size: 1.1em;
            color: #337;
            letter-spacing: 0.5px;
        }
        .custom-sounds-section {
            width: 100%;
            max-width: 650px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .recorder-controls {
            display: flex;
            gap: 7px;
            align-items: center;
        }
        #record-btn {
            transition: background 0.2s;
        }
        #record-btn.recording {
            background: #ffcccc !important;
        }
        #download-recording-btn {
            display: none !important;
        }
        #download-recording-btn:active {
            background: #63a8d7;
            color: #fff;
        }
        #record-timer {
            font-family: monospace;
            min-width: 40px;
            text-align: center;
        }
       
        /* LOGOUT BUTTON STYLE */
        #logout-btn {
            position: fixed;
            bottom: 20px;
            right: 22px;
            z-index: 99998;
            background: #ff4c64;
            color: #fff;
            border: none;
            border-radius: 22px;
            padding: 13px 26px 13px 22px;
            font-size: 1.1em;
            box-shadow: 0 3px 16px rgba(0,0,0,0.16);
            cursor: pointer;
            transition: background 0.16s, box-shadow 0.22s;
            opacity: 0.85;
            font-weight: bold;
            letter-spacing: 0.2px;
            display: flex;
            align-items: center;
            gap: 9px;
        }
        #logout-btn:hover {
            background: #cd253c;
            box-shadow: 0 4px 16px #e6455a66, 0 1.5px 7px #0002;
            opacity: 1;
        }
        #logout-btn svg {
            width: 19px;
            margin-right: 2px;
            vertical-align: middle;
            fill: #fff;
        }
    </style>

    <script>
    // ---- PASSWORD GUARD ----
    const PGUARD_PASS = '5w0ndeR';
    const PGUARD_LOCALSTORAGE_KEY = 'pguard_sb_auth';
    function pguard_todayDateStr() {
        const d = new Date();
        return d.getUTCFullYear() + "-" +
               ("0"+(d.getUTCMonth()+1)).slice(-2) + "-" +
               ("0"+d.getUTCDate()).slice(-2);
    }
    function pguard_is_authed() {
        try {
            const data = JSON.parse(localStorage.getItem(PGUARD_LOCALSTORAGE_KEY));
            if (data && typeof data === 'object' && data.pass === true && data.date === pguard_todayDateStr()) {
                return true;
            }
        } catch(e){}
        return false;
    }
    function pguard_set_authed() {
        const data = {pass:true, date:pguard_todayDateStr()};
        localStorage.setItem(PGUARD_LOCALSTORAGE_KEY, JSON.stringify(data));
    }
    function pguard_logout_at_midnight() {
        const now = new Date();
        const nextMidnight = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()+1, 0,0,1,0));
        setTimeout(() => {
            localStorage.removeItem(PGUARD_LOCALSTORAGE_KEY);
            location.reload();
        }, nextMidnight.getTime() - now.getTime());
    }

    function pguard_logout_now() {
        localStorage.removeItem(PGUARD_LOCALSTORAGE_KEY);
        location.reload();
    }

    function pguard_show_guard(cbOnAuth) {
        // If overlay exists, show and focus the box
        let existing = document.getElementById('pg-guard');
        if (existing) {
            existing.style.display = 'flex';
            let pf = document.getElementById('pg-pass-input');
            if(pf) setTimeout(()=>{ pf.focus();}, 40);
            return;
        }
        const guard = document.createElement('div');
        guard.id = "pg-guard";
        // Monochrome semi-transparent black overlay
        document.documentElement.appendChild(guard);
        guard.style.position = "fixed";
        guard.style.top = 0; guard.style.left = 0;
        guard.style.width = "100vw";
        guard.style.height = "100vh";
        guard.style.display = "flex";
        guard.style.justifyContent = "center";
        guard.style.alignItems = "center";
        guard.style.zIndex = 999999;
        guard.style.background = "rgba(0,0,0,0.93)";

        // inner container for styles
        const panel = document.createElement("div");
        panel.style.display = "flex";
        panel.style.flexDirection = "column";
        panel.style.alignItems = "center";
        panel.style.gap = "14px";
        panel.style.background = "#1a1a1a";
        panel.style.padding = "36px 32px 32px 32px";
        panel.style.borderRadius = "14px";
        panel.style.boxShadow = "0 8px 38px rgba(0,0,0,0.65), 0 1.5px 7px #fff1";
        panel.style.minWidth = "280px";
        panel.style.fontFamily = "monospace, monospace";
        panel.innerHTML = `
          <form id="pg-guard-form" autocomplete="on" style="display:flex;flex-direction:column;align-items:center;width:100%;font-family:monospace;">
            <label for="pg-pass-input"
              style="
                color: #fff;
                font-family: monospace, monospace;
                font-weight: bold;
                font-size: 1.25em;
                margin-bottom: 4px;
                letter-spacing: 1px;
                text-shadow: 0 2px 16px #000, 0 1px 0 #fff3;
              "
            >access soundboard</label>
            
            <!-- Username (enables browser password saving) -->
            <input id="pg-user-input" value="soundboard" name="username" type="text" readonly placeholder="Username (for saving)"
              autocomplete="username"
              style="font-size:1.08em;padding:8px 14px;border:1.5px solid #fff;border-radius:7px;background:#161616;color:#fff;width:200px;margin-bottom:8px;outline:none;box-shadow:0 2px 0 #0003,0 1px 0 #fff1;font-family:monospace, monospace;letter-spacing:.02em;transition:border .18s;position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;opacity:0;pointer-events:none;"  aria-hidden="true"  tabindex="-1" />
<input id="pg-pass-input" type="password" name="password" placeholder="Password" maxlength="32" required autocomplete="current-password"
                style="
                  font-size:1.08em;
                  padding:8px 14px;
                  border:1.5px solid #fff;
                  border-radius:7px;
                  background:#161616;
                  color:#fff;
                  width:200px;
                  margin-bottom:10px;
                  outline: none;
                  box-shadow: 0 2px 0 #0003, 0 1px 0 #fff1;
                  font-family:monospace, monospace;
                  letter-spacing: 0.1em;
                  transition: border 0.18s;
                "
                onfocus="this.style.borderColor='#fff';this.style.boxShadow='0 2px 0 #0005, 0 1px 0 #fff1';"
                onblur="this.style.borderColor='#fff';"
            />
            <button type="submit"
                style="
                  font-family: monospace, monospace;
                  font-size:1em;
                  padding:8px 28px;
                  border-radius:7px;
                  background:#fff;
                  color:#181818;
                  border:none;
                  cursor:pointer;
                  margin-top:8px;
                  font-weight:bold;
                  letter-spacing:1px;
                  box-shadow: 0 1.5px 7px #0002, 0 2px 16px #fff1;
                  transition: background 0.17s,color 0.17s;
                "
                onmouseover="this.style.background='#e2e2e2';this.style.color='#000'"
                onmouseout="this.style.background='#fff';this.style.color='#181818';"
            >
                ENTER
            </button>
            <div class="failmsg" id="pg-failmsg"
              style="
                color: #fff;
                font-size: .98em;
                font-family: monospace, monospace;
                font-weight: bold;
                min-height: 24px;
                margin-top: 6px;
                width: 100%;
                text-align: center;
                text-shadow: 0 2px 8px #000, 0 1px 0 #fff3;
              "
            ></div>
          </form>
        `;
        guard.appendChild(panel);

        const form = panel.querySelector('#pg-guard-form');
        const passField = panel.querySelector('#pg-pass-input');
        const failmsg = panel.querySelector('#pg-failmsg');

        function fail(txt) {
            failmsg.textContent = txt;
            passField.value = '';
            passField.focus();
            failmsg.style.color = "#fff";
            failmsg.style.textShadow = "0 1px 0 #fff3, 0 2px 8px #000";
        }
        form.addEventListener('submit', function(e){
            e.preventDefault();
            let v = passField.value.trim();
            if (v === PGUARD_PASS) {
                
        // Ask browser to save credentials (if supported)
        try {
          const userField = panel.querySelector('#pg-user-input');
          const username = userField ? userField.value.trim() : '';
          if (typeof pguard_maybe_save_password === 'function') {
            pguard_maybe_save_password(username, v);
          }
        } catch(_) {}
    pguard_set_authed();
                guard.style.opacity = "0";
                setTimeout(() => {
                    guard.style.display = 'none';
                    if (typeof cbOnAuth === 'function') cbOnAuth();
                }, 260);
                pguard_logout_at_midnight();
            } else {
                fail("Incorrect code.");
            }
        });
        // Make sure type box is focused, even if body is [style=visibility:hidden]
        setTimeout(()=>{ try { passField.focus(); } catch(e){} }, 120);
    }

    // Unlock logic: show password guard if needed
    function showGuardIfNeeded() {
        if (!pguard_is_authed()) {
            document.documentElement.style.overflow = 'hidden';
            window._sb_on_auth = () => {
                document.documentElement.style.overflow = '';
                // Also hide the overlay if present
                let guard = document.getElementById('pg-guard');
                if(guard) guard.style.display = 'none';
                // Show the body
                document.body.style.visibility = '';
            };
            // Ensure DOM is ready so <body> exists before we test
            if (document.readyState === "loading") {
                window.addEventListener('DOMContentLoaded', function(){
                    pguard_show_guard(window._sb_on_auth);
                });
            } else {
                pguard_show_guard(window._sb_on_auth);
            }
        } else {
            pguard_logout_at_midnight();
            // Make sure body is visible if already authed
            document.body.style.visibility = '';
            document.documentElement.style.overflow = '';
        }
    }

    // Run immediately when HTML is ready, as soon as possible
    // Only execute after DOM is available to avoid body being null
    if (document.readyState === "loading") {
        document.addEventListener('DOMContentLoaded', showGuardIfNeeded);
    } else {
        showGuardIfNeeded();
    }

    // Show/hide the body depending on if password is entered
    (function(){
        function check() {
            if ((function(){
                try {
                  var d=JSON.parse(localStorage.getItem('pguard_sb_auth'));
                  return d&&d.pass===true&&d.date===(
                    new Date().getUTCFullYear()+"-"+("0"+(new Date().getUTCMonth()+1)).slice(-2)+"-"+("0"+new Date().getUTCDate()).slice(-2)
                  );
                } catch(e){}
                return false;
              })()) {
              // Defensive: ensure body exists before accessing its style!
              if (document.body) {
                document.body.style.visibility = '';
              }
              document.documentElement.style.overflow = '';
              // Hide overlay if still present
              let g=document.getElementById('pg-guard'); if(g) g.style.display='none';
          } else {
              if (document.body) {
                document.body.style.visibility = 'hidden';
              }
              document.documentElement.style.overflow = 'hidden';
              // Show overlay
              pguard_show_guard();
          }
        }
        if (document.readyState === "loading") {
          document.addEventListener('DOMContentLoaded', check);
        } else {
          check();
        }
        window.addEventListener('storage', check);
        window._sb_on_auth = check;
      })();
    </script>
  </head>
  <body style="visibility:hidden;">
  <script>
    (function oneko() {
const isReducedMotion =
 window.matchMedia(`(prefers-reduced-motion: reduce)`) === true ||
 window.matchMedia(`(prefers-reduced-motion: reduce)`).matches === true;

if (isReducedMotion) return;

const nekoEl = document.createElement("div");

let nekoPosX = 32;
let nekoPosY = 32;

let mousePosX = 0;
let mousePosY = 0;

let frameCount = 0;
let idleTime = 0;
let idleAnimation = null;
let idleAnimationFrame = 0;

const nekoSpeed = 10;
const spriteSets = {
 idle: [[-3, -3]],
 alert: [[-7, -3]],
 scratchSelf: [
   [-5, 0],
   [-6, 0],
   [-7, 0],
 ],
 scratchWallN: [
   [0, 0],
   [0, -1],
 ],
 scratchWallS: [
   [-7, -1],
   [-6, -2],
 ],
 scratchWallE: [
   [-2, -2],
   [-2, -3],
 ],
 scratchWallW: [
   [-4, 0],
   [-4, -1],
 ],
 tired: [[-3, -2]],
 sleeping: [
   [-2, 0],
   [-2, -1],
 ],
 N: [
   [-1, -2],
   [-1, -3],
 ],
 NE: [
   [0, -2],
   [0, -3],
 ],
 E: [
   [-3, 0],
   [-3, -1],
 ],
 SE: [
   [-5, -1],
   [-5, -2],
 ],
 S: [
   [-6, -3],
   [-7, -2],
 ],
 SW: [
   [-5, -3],
   [-6, -1],
 ],
 W: [
   [-4, -2],
   [-4, -3],
 ],
 NW: [
   [-1, 0],
   [-1, -1],
 ],
};

function init() {
 nekoEl.id = "oneko";
 nekoEl.ariaHidden = true;
 nekoEl.style.width = "32px";
 nekoEl.style.height = "32px";
 nekoEl.style.position = "fixed";
 nekoEl.style.pointerEvents = "none";
 nekoEl.style.imageRendering = "pixelated";
 nekoEl.style.left = `${nekoPosX - 16}px`;
 nekoEl.style.top = `${nekoPosY - 16}px`;
 nekoEl.style.zIndex = 2147483647;

 let nekoFile = "https://github.com/adryd325/oneko.js/blob/main/oneko.gif?raw=trueoneko.gif"
 const curScript = document.currentScript
 if (curScript && curScript.dataset.cat) {
   nekoFile = curScript.dataset.cat
 }
 nekoEl.style.backgroundImage = `url(${nekoFile})`;

 document.body.appendChild(nekoEl);

 document.addEventListener("mousemove", function (event) {
   mousePosX = event.clientX;
   mousePosY = event.clientY;
 });

 window.requestAnimationFrame(onAnimationFrame);
}

let lastFrameTimestamp;

function onAnimationFrame(timestamp) {
 // Stops execution if the neko element is removed from DOM
 if (!nekoEl.isConnected) {
   return;
 }
 if (!lastFrameTimestamp) {
   lastFrameTimestamp = timestamp;
 }
 if (timestamp - lastFrameTimestamp > 100) {
   lastFrameTimestamp = timestamp
   frame()
 }
 window.requestAnimationFrame(onAnimationFrame);
}

function setSprite(name, frame) {
 const sprite = spriteSets[name][frame % spriteSets[name].length];
 nekoEl.style.backgroundPosition = `${sprite[0] * 32}px ${sprite[1] * 32}px`;
}

function resetIdleAnimation() {
 idleAnimation = null;
 idleAnimationFrame = 0;
}

function idle() {
 idleTime += 1;

 // every ~ 20 seconds
 if (
   idleTime > 10 &&
   Math.floor(Math.random() * 200) == 0 &&
   idleAnimation == null
 ) {
   let avalibleIdleAnimations = ["sleeping", "scratchSelf"];
   if (nekoPosX < 32) {
     avalibleIdleAnimations.push("scratchWallW");
   }
   if (nekoPosY < 32) {
     avalibleIdleAnimations.push("scratchWallN");
   }
   if (nekoPosX > window.innerWidth - 32) {
     avalibleIdleAnimations.push("scratchWallE");
   }
   if (nekoPosY > window.innerHeight - 32) {
     avalibleIdleAnimations.push("scratchWallS");
   }
   idleAnimation =
     avalibleIdleAnimations[
       Math.floor(Math.random() * avalibleIdleAnimations.length)
     ];
 }

 switch (idleAnimation) {
   case "sleeping":
     if (idleAnimationFrame < 8) {
       setSprite("tired", 0);
       break;
     }
     setSprite("sleeping", Math.floor(idleAnimationFrame / 4));
     if (idleAnimationFrame > 192) {
       resetIdleAnimation();
     }
     break;
   case "scratchWallN":
   case "scratchWallS":
   case "scratchWallE":
   case "scratchWallW":
   case "scratchSelf":
     setSprite(idleAnimation, idleAnimationFrame);
     if (idleAnimationFrame > 9) {
       resetIdleAnimation();
     }
     break;
   default:
     setSprite("idle", 0);
     return;
 }
 idleAnimationFrame += 1;
}

function frame() {
 frameCount += 1;
 const diffX = nekoPosX - mousePosX;
 const diffY = nekoPosY - mousePosY;
 const distance = Math.sqrt(diffX ** 2 + diffY ** 2);

 if (distance < nekoSpeed || distance < 48) {
   idle();
   return;
 }

 idleAnimation = null;
 idleAnimationFrame = 0;

 if (idleTime > 1) {
   setSprite("alert", 0);
   // count down after being alerted before moving
   idleTime = Math.min(idleTime, 7);
   idleTime -= 1;
   return;
 }

 let direction;
 direction = diffY / distance > 0.5 ? "N" : "";
 direction += diffY / distance < -0.5 ? "S" : "";
 direction += diffX / distance > 0.5 ? "W" : "";
 direction += diffX / distance < -0.5 ? "E" : "";
 setSprite(direction, frameCount);

 nekoPosX -= (diffX / distance) * nekoSpeed;
 nekoPosY -= (diffY / distance) * nekoSpeed;

 nekoPosX = Math.min(Math.max(16, nekoPosX), window.innerWidth - 16);
 nekoPosY = Math.min(Math.max(16, nekoPosY), window.innerHeight - 16);

 nekoEl.style.left = `${nekoPosX - 16}px`;
 nekoEl.style.top = `${nekoPosY - 16}px`;
}

init();
})(); // oneko.js: https://github.com/adryd325/oneko.js
 
 (function oneko() {
   const isReducedMotion =
     window.matchMedia(`(prefers-reduced-motion: reduce)`) === true ||
     window.matchMedia(`(prefers-reduced-motion: reduce)`).matches === true;
 
   if (isReducedMotion) return;
 
   const nekoEl = document.createElement("div");
 
   let nekoPosX = 32;
   let nekoPosY = 32;
 
   let mousePosX = 0;
   let mousePosY = 0;
 
   let frameCount = 0;
   let idleTime = 0;
   let idleAnimation = null;
   let idleAnimationFrame = 0;
 
   const nekoSpeed = 10;
   const spriteSets = {
     idle: [[-3, -3]],
     alert: [[-7, -3]],
     scratchSelf: [
       [-5, 0],
       [-6, 0],
       [-7, 0],
     ],
     scratchWallN: [
       [0, 0],
       [0, -1],
     ],
     scratchWallS: [
       [-7, -1],
       [-6, -2],
     ],
     scratchWallE: [
       [-2, -2],
       [-2, -3],
     ],
     scratchWallW: [
       [-4, 0],
       [-4, -1],
     ],
     tired: [[-3, -2]],
     sleeping: [
       [-2, 0],
       [-2, -1],
     ],
     N: [
       [-1, -2],
       [-1, -3],
     ],
     NE: [
       [0, -2],
       [0, -3],
     ],
     E: [
       [-3, 0],
       [-3, -1],
     ],
     SE: [
       [-5, -1],
       [-5, -2],
     ],
     S: [
       [-6, -3],
       [-7, -2],
     ],
     SW: [
       [-5, -3],
       [-6, -1],
     ],
     W: [
       [-4, -2],
       [-4, -3],
     ],
     NW: [
       [-1, 0],
       [-1, -1],
     ],
   };
 
   function init() {
     nekoEl.id = "oneko";
     nekoEl.ariaHidden = true;
     nekoEl.style.width = "32px";
     nekoEl.style.height = "32px";
     nekoEl.style.position = "fixed";
     nekoEl.style.pointerEvents = "none";
     nekoEl.style.imageRendering = "pixelated";
     nekoEl.style.left = `${nekoPosX - 16}px`;
     nekoEl.style.top = `${nekoPosY - 16}px`;
     nekoEl.style.zIndex = 2147483647;
 
     let nekoFile = "https://github.com/adryd325/oneko.js/blob/main/oneko.gif?raw=true"
     const curScript = document.currentScript
     if (curScript && curScript.dataset.cat) {
       nekoFile = curScript.dataset.cat
     }
     nekoEl.style.backgroundImage = `url(${nekoFile})`;
 
     document.body.appendChild(nekoEl);
 
     document.addEventListener("mousemove", function (event) {
       mousePosX = event.clientX;
       mousePosY = event.clientY;
     });
 
     window.requestAnimationFrame(onAnimationFrame);
   }
 
   let lastFrameTimestamp;
 
   function onAnimationFrame(timestamp) {
     // Stops execution if the neko element is removed from DOM
     if (!nekoEl.isConnected) {
       return;
     }
     if (!lastFrameTimestamp) {
       lastFrameTimestamp = timestamp;
     }
     if (timestamp - lastFrameTimestamp > 100) {
       lastFrameTimestamp = timestamp
       frame()
     }
     window.requestAnimationFrame(onAnimationFrame);
   }
 
   function setSprite(name, frame) {
     const sprite = spriteSets[name][frame % spriteSets[name].length];
     nekoEl.style.backgroundPosition = `${sprite[0] * 32}px ${sprite[1] * 32}px`;
   }
 
   function resetIdleAnimation() {
     idleAnimation = null;
     idleAnimationFrame = 0;
   }
 
   function idle() {
     idleTime += 1;
 
     // every ~ 20 seconds
     if (
       idleTime > 10 &&
       Math.floor(Math.random() * 200) == 0 &&
       idleAnimation == null
     ) {
       let avalibleIdleAnimations = ["sleeping", "scratchSelf"];
       if (nekoPosX < 32) {
         avalibleIdleAnimations.push("scratchWallW");
       }
       if (nekoPosY < 32) {
         avalibleIdleAnimations.push("scratchWallN");
       }
       if (nekoPosX > window.innerWidth - 32) {
         avalibleIdleAnimations.push("scratchWallE");
       }
       if (nekoPosY > window.innerHeight - 32) {
         avalibleIdleAnimations.push("scratchWallS");
       }
       idleAnimation =
         avalibleIdleAnimations[
           Math.floor(Math.random() * avalibleIdleAnimations.length)
         ];
     }
 
     switch (idleAnimation) {
       case "sleeping":
         if (idleAnimationFrame < 8) {
           setSprite("tired", 0);
           break;
         }
         setSprite("sleeping", Math.floor(idleAnimationFrame / 4));
         if (idleAnimationFrame > 192) {
           resetIdleAnimation();
         }
         break;
       case "scratchWallN":
       case "scratchWallS":
       case "scratchWallE":
       case "scratchWallW":
       case "scratchSelf":
         setSprite(idleAnimation, idleAnimationFrame);
         if (idleAnimationFrame > 9) {
           resetIdleAnimation();
         }
         break;
       default:
         setSprite("idle", 0);
         return;
     }
     idleAnimationFrame += 1;
   }
 
   function frame() {
     frameCount += 1;
     const diffX = nekoPosX - mousePosX;
     const diffY = nekoPosY - mousePosY;
     const distance = Math.sqrt(diffX ** 2 + diffY ** 2);
 
     if (distance < nekoSpeed || distance < 48) {
       idle();
       return;
     }
 
     idleAnimation = null;
     idleAnimationFrame = 0;
 
     if (idleTime > 1) {
       setSprite("alert", 0);
       // count down after being alerted before moving
       idleTime = Math.min(idleTime, 7);
       idleTime -= 1;
       return;
     }
 
     let direction;
     direction = diffY / distance > 0.5 ? "N" : "";
     direction += diffY / distance < -0.5 ? "S" : "";
     direction += diffX / distance > 0.5 ? "W" : "";
     direction += diffX / distance < -0.5 ? "E" : "";
     setSprite(direction, frameCount);
 
     nekoPosX -= (diffX / distance) * nekoSpeed;
     nekoPosY -= (diffY / distance) * nekoSpeed;
 
     nekoPosX = Math.min(Math.max(16, nekoPosX), window.innerWidth - 16);
     nekoPosY = Math.min(Math.max(16, nekoPosY), window.innerHeight - 16);
 
     nekoEl.style.left = `${nekoPosX - 16}px`;
     nekoEl.style.top = `${nekoPosY - 16}px`;
   }
 
   init();
 })();
 </script>
    <h1>le soundboard™</h1>
    <div class="controls-row">
      <form id="add-sound-form" autocomplete="off">
          <input type="text" id="sound-name" placeholder="Sound Name" required maxlength="32">
          <input type="file" id="sound-file" accept=".mp3,.ogg,.m4a,audio/mp3,audio/ogg,audio/mpeg,audio/x-m4a,audio/mp4" required>
          <button type="submit">Add Sound</button>
      </form>
      <div class="recorder-controls">
          <button type="button" id="record-btn">Record</button>
          <span id="record-timer"></span>
          <a id="download-recording-btn" style="display:none;">Download Recording</a>
      </div>
      <button type="button" id="stop-all-btn" class="stop-all-btn">Stop All Sounds</button>
    </div>

    <div class="section-title" id="default-sounds-label">Default Sounds</div>
    <div class="soundboard-buttons" id="soundboard-buttons">
        <!-- Default sound buttons will be inserted here -->
    </div>

    <div class="custom-sounds-section">
        <div class="section-title" id="custom-sounds-label" style="display:none;">Custom Sounds</div>
        <div class="custom-sounds-buttons" id="custom-sounds-buttons">
            <!-- Custom sound buttons will be inserted here -->
        </div>
    </div>

    <script src="https://unpkg.com/lamejs@1.2.0/lame.min.js"></script>
    <script>
      // Keep track of all currently playing audios
      let playingAudios = [];

      // Default sounds
      const defaultSounds = [
        {name: "Vine Boom", url: "https://www.myinstants.com/media/sounds/vine-boom.mp3"},
        {name: "Airhorn", url: "https://www.myinstants.com/media/sounds/mlg-airhorn.mp3"},
        {name: "Anime Wow", url: "https://www.myinstants.com/media/sounds/anime-wow-sound-effect.mp3"},
        {name: "67", url: "https://www.myinstants.com/media/sounds/67_SQlv2Xv.mp3"},
        {name: "forbidden button", url: "https://www.myinstants.com/media/sounds/i-like-femboys_6JHIoHH.mp3"},
        {name: "oh ma gawd", url: "https://www.myinstants.com/media/sounds/oh-my-god-meme.mp3"},
        {name: "shut", url: "https://www.myinstants.com/media/sounds/sybau.mp3"},
        {name: "bye bye", url: "https://www.myinstants.com/media/sounds/bye-bye-mewing_fMVssQz.mp3"},
        {name: "jet2 holiday", url: "https://www.myinstants.com/media/sounds/nothing-beats-a-jet2-holiday_IeBO1Mr.mp3"},
        {name: "pls speed i need ts", url: "https://www.myinstants.com/media/sounds/please-speed-i-need-this.mp3"},
        {name: "metal pipe", url: "https://www.myinstants.com/media/sounds/metal-pipe-clang.mp3"},
        {name: "cuh", url: "https://www.myinstants.com/media/sounds/ahhhhhhhhhhhhhhhh_8axRFzx.mp3"},
        {name: "auhhhhhh", url: "https://files.catbox.moe/ba720q.mp3"},
        {name: "social credit", url: "https://www.myinstants.com/media/sounds/999-social-credit-siren.mp3"},
        {name: "flashbang", url: "https://www.myinstants.com/media/sounds/flashbang-jumpscare-loud.mp3"},
        {name: "hog rider (rory edition)", url: "https://www.myinstants.com/media/sounds/hog-rider-loud.mp3"},
        // 29 new sounds added 29.10.2025
        {name: "amethyst reaction (zoink)", url: "https://files.catbox.moe/mpcfbz.mp3"},
        {name: "Bone Crack", url: "https://www.myinstants.com/media/sounds/bone-crack-meme.mp3"},
        {name: "Dead Nokia", url: "https://www.myinstants.com/media/sounds/dead-nokia.mp3"},
        {name: "Apple Pay", url: "https://files.catbox.moe/60uepl.mp3"},
        {name: "Get Out", url: "https://www.myinstants.com/media/sounds/tuco-get-out.mp3"},
        {name: "big brain", url: "https://www.myinstants.com/media/sounds/galaxy-meme.mp3"},
        {name: "Android notification", url: "https://www.myinstants.com/media/sounds/android-sound-effect-meme_tcbuori.mp3"},
        {name: "You Are An Idiot", url: "https://www.myinstants.com/media/sounds/you-are-an-idiot.mp3"},
        {name: "thirtydollarhaircut", url: "https://www.myinstants.com/media/sounds/dont-you-lecture-me-with-your-30-haircut_HhMrU7I.mp3"},
        {name: "Taco Bell", url: "https://www.myinstants.com/media/sounds/taco-bell-bong-sfx.mp3"},
        {name: "Fire In The Hole", url: "https://www.myinstants.com/media/sounds/fire-in-the-hole-loud.mp3"},
        {name: "Water On The Hill", url: "https://www.myinstants.com/media/sounds/water-on-the-hill.mp3"},
        {name: "Among Us Role Reveal", url: "https://www.myinstants.com/media/sounds/among-us-role-reveal-sound.mp3"},
        {name: "that one bossfight", url: "https://www.myinstants.com/media/sounds/drip-goku-meme-song-original-dragon-ball-super-music-clash-of-gods-in-description.mp3"},
        {name: "sigma", url: "https://www.myinstants.com/media/sounds/gigachad-phonk-house.mp3"},
        {name: "squid game salesman", url: "https://www.myinstants.com/media/sounds/salesman-squid-game-edit-audio-blah-phonk.mp3"},
        {name: "harry potter", url: "https://files.catbox.moe/o2v1zw.ogg"},
        {name: "accepting fate", url: "https://files.catbox.moe/5usqw5.mp3"},
        {name: "deez nuts", url: "https://files.catbox.moe/04ll2j.mp3"},
        {name: "i love gd colonge", url: "https://files.catbox.moe/wvg773.mp3"},
        {name: "mr beast phonk", url: "https://files.catbox.moe/usddy9.mp3"},
        {name: "scream", url: "https://files.catbox.moe/6tz383.mp3"},
        {name: "stop it, get some help", url: "https://files.catbox.moe/4c8dul.mp3"},
        {name: "super idol (shite mic edition)", url: "https://files.catbox.moe/kyvj16.mp3"},
        {name: "super idol", url: "https://files.catbox.moe/9i9muh.mp3"},
        {name: "what did he say?", url: "https://files.catbox.moe/pcmul9.mp3"},
        {name: "piano tiles?", url: "https://files.catbox.moe/oympii.mp3"},
        {name: "nay", url: "https://files.catbox.moe/xwx3aj.mp3"},
        {name: "fbi", url: "https://files.catbox.moe/cahnir.mp3"},
        {name: "fart", url: "https://files.catbox.moe/netklr.ogg"},
        {name: "67 song", url: "https://files.catbox.moe/zpg4t8.ogg"},
        // 17 new sounds 30.10.2025
        {name: "emotional damage", url: "https://www.myinstants.com/media/sounds/emotional-damage-meme.mp3"},
        {name: "spongebob and rap god", url: "https://www.myinstants.com/media/sounds/spongebob-with-eminem.mp3"},
      //  {name: "placeholder", url: "url"}
      {name: "lets go gambling!", url: "https://www.myinstants.com/media/sounds/lets-go-gambling_Ci8E7hL.mp3"},
      {name: "awh dangit", url: "https://www.myinstants.com/media/sounds/aw-dangit.mp3"},
      {name: "win", url: "https://www.myinstants.com/media/sounds/lets-go-gambling-win.mp3"},
      {name: "burp", url: "https://files.catbox.moe/wgu97m.mp3"},
      {name: "fire in da hole song", url: "https://files.catbox.moe/ua2brk.mp3"},
      {name: "lie buzzer", url: "https://files.catbox.moe/7qb5i5.mp3"},
      {name: "ninja gets shot lol", url: "https://files.catbox.moe/evwi4c.ogg"},
      {name: "slap", url: "https://files.catbox.moe/0t33ms.mp3"},
      {name: "ios notification", url: "https://www.myinstants.com/media/sounds/notification_o14egLP.mp3"},
      {name: "ios ringtone", url: "https://www.myinstants.com/media/sounds/toque-do-iphone-estourado.mp3"},
      {name: "im under da wa'er", url: "https://www.myinstants.com/media/sounds/y2mate_HOnnyD0.mp3"},
      {name: "ding dong eat it up", url: "https://www.myinstants.com/media/sounds/ding-dong-eat-it-up-indian-version.mp3"},
      {name: "W SPEED song but its brainrot (3 min lol)", url: "https://files.catbox.moe/79anwb.mp3"},
      {name: "bluetooth device", url: "https://www.myinstants.com/media/sounds/the-bluetooth-device-is-ready-to-pair.mp3"},
      {name: "censored beep", url: "https://www.myinstants.com/media/sounds/unbenannt_M7OcDIp.mp3"},
      {name: "kahoot and the real slim shady (2 min lol)", url: "https://files.catbox.moe/e9oe78.mp3"},
      ];

      // Keys for localStorage
      const LOCALSTORAGE_KEY = "customSoundboardSounds-v1";

      // Utility: Read user sounds from localStorage
      function getUserSounds() {
        const stored = localStorage.getItem(LOCALSTORAGE_KEY);
        if (!stored) return [];
        try {
          return JSON.parse(stored);
        } catch(e) {
          return [];
        }
      }

      // Utility: Write user sounds to localStorage
      function setUserSounds(list) {
        localStorage.setItem(LOCALSTORAGE_KEY, JSON.stringify(list));
      }

      // Render sound buttons (defaults or custom)
      function renderButtons(container, sounds, {custom, removeBtn}={}) {
        container.innerHTML = '';
        sounds.forEach((sound, i) => {
          const btn = document.createElement('button');
          btn.type = "button";
          btn.className = "soundboard-btn";
          btn.textContent = sound.name;
          btn.dataset.sound = sound.url;
          btn.addEventListener('click', function (e) {
            // Play sound and track for stopping
            e.stopPropagation();
            const audio = new Audio(btn.getAttribute('data-sound'));
            playingAudios.push(audio);
            audio.play();
            // Remove audio from the list when done
            audio.addEventListener('ended', () => {
                playingAudios = playingAudios.filter(a => a !== audio);
            });
            audio.addEventListener('pause', () => {
                playingAudios = playingAudios.filter(a => a !== audio);
            });
          });

          // Add remove button only for user sounds
          if (custom && removeBtn) {
            const remBtn = document.createElement('button');
            remBtn.type = 'button';
            remBtn.className = 'remove-btn';
            remBtn.title = "Delete this custom sound";
            remBtn.textContent = '✕';
            remBtn.addEventListener('click', (ev) => {
              ev.stopPropagation();
              deleteUserSound(i);
            });
            btn.appendChild(remBtn);
          }
          container.appendChild(btn);
        });
      }

      // Remove user's custom sound at index
      function deleteUserSound(index) {
        const userSounds = getUserSounds();
        userSounds.splice(index, 1);
        setUserSounds(userSounds);
        renderSoundboard();
      }

      // Render both sections
      function renderSoundboard() {
        // Defaults
        renderButtons(document.getElementById('soundboard-buttons'), defaultSounds, {custom:false});
        // Customs
        const userSounds = getUserSounds();
        const customSection = document.getElementById('custom-sounds-section');
        const customLabel = document.getElementById('custom-sounds-label');
        const customBtns = document.getElementById('custom-sounds-buttons');
        renderButtons(customBtns, userSounds, {custom:true, removeBtn:true});
        // Show/hide label based on contents
        if (userSounds && userSounds.length > 0) {
          customLabel.style.display = "";
        } else {
          customLabel.style.display = "none";
        }
      }

      // Handle add sound form (with m4a support)
      document.getElementById('add-sound-form').addEventListener('submit', function (e) {
        e.preventDefault();

        const nameInput = document.getElementById('sound-name');
        const fileInput = document.getElementById('sound-file');
        const files = fileInput.files;

        if (!files || !files.length) {
          alert("Please choose a sound file.");
          return;
        }

        const file = files[0];
        const allowedExts = ['mp3', 'ogg', 'm4a'];
        const ext = file.name.split('.').pop().toLowerCase();

        if (!allowedExts.includes(ext)) {
          alert('Only .mp3, .ogg, and .m4a files are supported.');
          return;
        }

        // Use reader.onloadend for reliability across browsers
        const reader = new FileReader();
        reader.onloadend = function (evt) {
          if (!evt.target.result) {
            alert("Could not read file.");
            return;
          }
          const dataUrl = evt.target.result;
          const userSounds = getUserSounds();
          userSounds.push({
            name: nameInput.value.trim() || file.name,
            url: dataUrl
          });
          setUserSounds(userSounds);
          renderSoundboard();
          nameInput.value = '';
          fileInput.value = '';
        };
        reader.onerror = function (evt) {
          alert("Error loading file.");
        };
        reader.readAsDataURL(file);
      });

      // Stop all sounds logic
      document.getElementById('stop-all-btn').addEventListener('click', function() {
        playingAudios.forEach(audio => {
          try {
            audio.pause();
            audio.currentTime = 0;
          } catch(e){}
        });
        playingAudios = [];
      });

      // Audio recorder feature (downloads a file so user can import it) - now produces mp3!
      let mediaRecorder = null;
      let audioChunks = [];
      let recordTimer = null;
      let recordStartT = 0;
      let recordStream = null;

      const recordBtn = document.getElementById('record-btn');
      const downloadBtn = document.getElementById('download-recording-btn');
      const timerSpan = document.getElementById('record-timer');

      function formatTimer(ms) {
        const secs = Math.floor(ms/1000);
        const min = Math.floor(secs/60);
        const remS = secs % 60;
        return `${String(min).padStart(2, '0')}:${String(remS).padStart(2, '0')}`;
      }

      function startRecording() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          alert("Your browser does not support microphone recording.");
          return;
        }
        recordBtn.disabled = true;
        navigator.mediaDevices.getUserMedia({ audio: true })
        .then(function(stream) {
          audioChunks = [];
          recordStream = stream;

          // Force mimeType to audio/webm for browser compatibility
          let mimeType = "audio/webm";
          if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('audio/webm')) {
            mimeType = 'audio/webm';
          }

          try {
            mediaRecorder = new MediaRecorder(stream, { mimeType });
          } catch(e) {
            try {
              mediaRecorder = new MediaRecorder(stream);
            } catch(e2) {
              alert('Could not start audio recorder.');
              recordBtn.disabled = false;
              return;
            }
          }
          mediaRecorder.ondataavailable = function(event) {
            if (event.data.size > 0) {
              audioChunks.push(event.data);
            }
          };
          mediaRecorder.onstop = async function() {
            if (recordStream) {
              recordStream.getTracks().forEach(track => track.stop());
              recordStream = null;
            }
            // Convert recorded WebM audio to mp3
            const blob = new Blob(audioChunks, { type: mediaRecorder.mimeType });
            const arrayBuffer = await blob.arrayBuffer();
            const webmBuffer = new Uint8Array(arrayBuffer);

            // We'll decode the webm in an AudioContext and encode to mp3 via lamejs
            let mp3Blob = null;
            try {
              const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
              let audioBuffer = null;
              try {
                audioBuffer = await audioCtx.decodeAudioData(arrayBuffer.slice(0));
              } catch(err) {
                alert("Could not decode recorded audio. Browser may not support decoding WebM audio.");
                audioCtx.close();
                resetRecordingUI();
                return;
              }

              const channelCount = audioBuffer.numberOfChannels;
              const samples = audioBuffer.length;
              const sampleRate = audioBuffer.sampleRate;

              // Prepare for lamejs (16bit PCM only, single or stereo)
              let samplesL = audioBuffer.getChannelData(0);
              let samplesR = channelCount > 1 ? audioBuffer.getChannelData(1) : null;
              // Convert from float ([-1,1]) to 16-bit PCM
              function floatTo16BitPCM(input) {
                let output = new Int16Array(input.length);
                for (let i = 0; i < input.length; i++) {
                  let s = Math.max(-1, Math.min(1, input[i]));
                  output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                }
                return output;
              }
              let left = floatTo16BitPCM(samplesL);
              let right = samplesR ? floatTo16BitPCM(samplesR) : null;

              // Encode with lamejs
              const mp3encoder = new lamejs.Mp3Encoder(channelCount, sampleRate, 128);
              let mp3Data = [];
              let blockSize = 1152;
              for (let i = 0; i < left.length; i += blockSize) {
                let leftChunk = left.subarray(i, i + blockSize);
                let rightChunk = right ? right.subarray(i, i + blockSize) : undefined;
                let mp3buf;
                if (channelCount > 1 && rightChunk) {
                  mp3buf = mp3encoder.encodeBuffer(leftChunk, rightChunk);
                } else {
                  mp3buf = mp3encoder.encodeBuffer(leftChunk);
                }
                if (mp3buf.length > 0) mp3Data.push(mp3buf);
              }
              let encFinal = mp3encoder.flush();
              if (encFinal.length > 0) mp3Data.push(encFinal);

              mp3Blob = new Blob(mp3Data, { type: "audio/mp3" });
              audioCtx.close();

              // Download
              const url = URL.createObjectURL(mp3Blob);
              downloadBtn.href = url;
              downloadBtn.download = 'custom_sound.mp3';
              downloadBtn.style.display = 'inline-block';
              downloadBtn.dataset.ext = 'mp3';

              setTimeout(() => {
                downloadBtn.click();
              }, 50);

            } catch(err) {
              alert("MP3 encoding failed: " + err.message);
              resetRecordingUI();
              return;
            }
            resetRecordingUI();
            timerSpan.textContent = formatTimer(Date.now() - recordStartT);
          };
          function resetRecordingUI() {
            recordBtn.textContent = 'Record';
            recordBtn.disabled = false;
            recordBtn.classList.remove('recording');
            clearInterval(recordTimer);
          }
          mediaRecorder.start();
          recordBtn.classList.add('recording');
          recordBtn.textContent = 'Stop';
          recordBtn.disabled = false;
          downloadBtn.style.display = 'none';
          recordStartT = Date.now();
          timerSpan.textContent = '00:00';
          recordTimer = setInterval(function() {
            timerSpan.textContent = formatTimer(Date.now() - recordStartT);
          }, 400);
        })
        .catch(function(err) {
          alert("Could not access microphone.");
          recordBtn.disabled = false;
        });
      }

      function stopRecording() {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
          clearInterval(recordTimer);
        }
      }

      recordBtn.addEventListener('click', function() {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          stopRecording();
          recordBtn.disabled = true; // Will be re-enabled when onstop
        } else {
          startRecording();
        }
      });

      // Reset download link on click and remove URL for cleanup
      downloadBtn.addEventListener('click', function() {
        setTimeout(() => {
          if (downloadBtn.href.startsWith('blob:')) {
            URL.revokeObjectURL(downloadBtn.href);
          }
          downloadBtn.style.display = 'none';
          timerSpan.textContent = '';
        }, 400);
      });

      // Render on page load
      renderSoundboard();

      // --- LOGOUT BUTTON functionality ---
      window.pguard_logout_now = function() {
        localStorage.removeItem('pguard_sb_auth');
        location.reload();
      };
    </script>
    <p><a href="https://forms.gle/Z2Yn3b8sE5wUMRJB6" target="_blank" rel="noopener">submit your dumb sounds here</a></p>
    <p>29 new sounds added 29.10.2025</p>
    <p>17 more sounds added 30.10.2025</p>
    <div style="display: flex; justify-content: center; gap: 20px; margin: 20px 0;">
      <img src="https://files.catbox.moe/irwkza.jpg" style="max-width: 290px; display: block;">
      <img src="https://files.catbox.moe/2t2nk8.png" style="max-width: 290px; display: block;">
    </div>
    <!-- LOGOUT BUTTON (bottom right) -->
    <button id="logout-btn" type="button" onclick="pguard_logout_now()" title="Log out and lock the soundboard" aria-label="Log out">
      Log out
    </button>

<script>
// Minimal, safe: store credentials when supported (requires HTTPS or localhost)
async function pguard_maybe_save_password(username, password) {
  try {
    if ('credentials' in navigator && window.PasswordCredential) {
      const id = (username && username.trim()) || (location.hostname || 'soundboard');
      const cred = new PasswordCredential({ id, name: 'Soundboard', password });
      await navigator.credentials.store(cred);
    }
  } catch (e) { /* ignore */ }
}
</script>

</body>
</html>
