<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Live cursors + drawing</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root{
    --bg:#0f172a; --ink:#e5e7eb; --muted:#94a3b8; --panel:#0b1220; --border:#223049;
    --accent:#22d3ee; --ok:#10b981; --bad:#ef4444;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background: radial-gradient(1200px 900px at 10% -10%, #16223d 0%, var(--bg) 55%);
    color:var(--ink); font:16px/1.4 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  }
  header{
    position:sticky; top:0; z-index:3; backdrop-filter: blur(8px) saturate(1.1);
    background: color-mix(in oklab, #0b1220ee 82%, transparent);
    border-bottom:1px solid var(--border);
  }
  .wrap{ max-width:1200px; margin:0 auto; padding:14px 16px; }
  .row{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
  .title{ font-weight:800; letter-spacing:.25px }
  .muted{ color:var(--muted) }

  main{ max-width:1200px; margin:18px auto; padding:0 16px 24px }
  .board{
    position:relative; border:1px solid var(--border); border-radius:16px;
    background: color-mix(in oklab, var(--panel) 90%, transparent); min-height:70vh;
    overflow:hidden;
  }

  /* ---- Toolbar (outside board) ----- */
  .tools{
    position:sticky; top:12px; z-index:5;
    display:flex; gap:8px; align-items:center; flex-wrap:wrap;
    background: rgba(11,18,32,.75); border:1px solid var(--border); padding:8px; border-radius:12px;
    backdrop-filter: blur(6px);
    margin-bottom:12px;
  }
  .group{ display:flex; gap:8px; align-items:center; }
  .btn{ border:1px solid var(--border); background:#11192a; color:var(--ink);
        padding:6px 10px; border-radius:10px; cursor:pointer; font-weight:700 }
  .btn.on{ outline:2px solid var(--accent); }
  .name{ border:1px solid var(--border); background:#0b1220; color:var(--ink);
         padding:6px 10px; border-radius:10px; width:160px; }
  .status{ display:flex; align-items:center; gap:6px }
  .dotstat{ width:10px; height:10px; border-radius:50%; background:var(--bad) }
  .dotstat.ok{ background:var(--ok) }
  .slider{ accent-color: var(--accent) }
  label.toggle{ display:flex; gap:6px; align-items:center; font-size:13px; color:var(--muted) }
  label.toggle input{ accent-color: var(--accent) }

  canvas#pad{ position:absolute; inset:0; width:100%; height:100%; z-index:1; }

  /* ---- Roster (online users) ---- */
  .roster{
    position:absolute; left:12px; top:12px; bottom:12px; width:210px; z-index:2;
    background: rgba(11,18,32,.75); border:1px solid var(--border); border-radius:12px;
    backdrop-filter: blur(6px);
    padding:10px; overflow:auto;
  }
  .roster h4{ margin:0 0 8px 0; font-size:13px; color:var(--muted); font-weight:700; letter-spacing:.3px }
  .u{
    display:flex; align-items:center; gap:8px; padding:6px 8px; border-radius:10px;
    border:1px solid transparent;
  }
  .u.you{ background:#0e1728; border-color:var(--border) }
  .udot{ width:10px; height:10px; border-radius:50%; box-shadow:0 0 0 1px rgba(0,0,0,.35) inset }
  .uname{ font-size:13px }
  .ucolor{ font-size:11px; color:var(--muted); margin-left:auto }

  /* ---- Floating text box ---- */
  .textbox{
    position:absolute; z-index:3; min-width:40px; max-width:50%;
    border:1px dashed var(--border); background:#0b1220; color:var(--ink);
    padding:6px 8px; border-radius:8px; outline:none;
  }

  /* ---- Multiplayer cursors ---- */
  .mcursor{
    position:fixed; left:0; top:0;
    transform:translate(-9999px,-9999px);
    pointer-events:none; z-index:99999;
    transition:transform 40ms linear;
    will-change:transform;
    display:flex; align-items:center;
  }
  .mcursor .dot{
    position:relative;
    width:12px; height:12px; border-radius:50%;
    background:var(--c,#22d3ee);
    box-shadow:0 0 0 2px rgba(0,0,0,.25);
    transform:translate(-50%,-50%);
  }
  .mcursor .tag{
    margin-left:10px; margin-top:-4px;
    padding:2px 6px; border-radius:999px;
    font:12px/1.2 ui-sans-serif,system-ui;
    color:#fff; background:rgba(0,0,0,.5);
    transform:translateY(-50%); white-space:nowrap;
  }
  .mcursor.down .dot{ transform:translate(-50%,-50%) scale(.85) }

  /* pointy cursor style (SVG arrow) */
  .mcursor .arrow{ display:none; color:var(--c,#22d3ee); filter: drop-shadow(0 0 0.5px rgba(0,0,0,.35)) }
  body.pointy .mcursor .dot{ display:none }
  body.pointy .mcursor .arrow{
    display:block; width:18px; height:18px;
    transform: translate(-35%,-35%); /* tip under pointer */
  }

  @media (max-width: 820px){
    .roster{ width:170px }
  }
</style>
</head>
<body>
  <header>
    <div class="wrap row">
      <div class="title">Live cursors + whiteboard</div>
      <div class="row" style="gap:10px">
        <input id="nick" class="name" placeholder="nickname (optional)">
        <div class="status"><span class="dotstat" id="dot"></span><span id="stat" class="muted">connectingâ€¦</span></div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <!-- TOOLBAR (no timer) -->
    <div class="tools">
      <div class="group">
        <button id="modePointer" class="btn on">Pointer</button>
        <button id="modeDraw"    class="btn">Draw</button>
        <button id="modeText"    class="btn">Text</button>
      </div>
      <div class="group">
        <input id="color" type="color" value="#22d3ee" title="color">
        <input id="size" class="slider" type="range" min="2" max="60" value="10" title="size">
        <button id="clear" class="btn">Clear</button>
        <button id="importBtn" class="btn">Import</button>
      </div>
      <div class="group" style="border-left:1px solid var(--border); padding-left:8px">
        <label class="toggle"><input type="checkbox" id="showMine"> show my cursor</label>
        <label class="toggle"><input type="checkbox" id="pointy"> pointy cursors</label>
      </div>
    </div>

    <div class="board" id="board">
      <aside class="roster" id="roster">
        <h4>Online</h4>
        <div id="rosterList"></div>
      </aside>
      <canvas id="pad"></canvas>
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
  (() => {
    const SUPABASE_URL  = 'https://duwdxzrdyqlzrjqcnnuk.supabase.co';
    const SUPABASE_ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImR1d2R4enJkeXFsenJqcWNubnVrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc0MDUyNDgsImV4cCI6MjA3Mjk4MTI0OH0.SXRIwgyCSsS7yd9DS-5-cNCKdqRMwwYQ2GtAguOUYgk';

    const board = document.getElementById('board');
    const canvas = document.getElementById('pad');
    const ctx = canvas.getContext('2d');

    const colorEl = document.getElementById('color');
    const sizeEl  = document.getElementById('size');
    const btnPointer = document.getElementById('modePointer');
    const btnDraw    = document.getElementById('modeDraw');
    const btnText    = document.getElementById('modeText');
    const btnClear   = document.getElementById('clear');
    const btnImport  = document.getElementById('importBtn');

    const dot  = document.getElementById('dot');
    const stat = document.getElementById('stat');
    const nick = document.getElementById('nick');
    const rosterList = document.getElementById('rosterList');

    const showMineEl = document.getElementById('showMine');
    const pointyEl   = document.getElementById('pointy');

    const roomName = 'cursors:' + location.pathname;

    // Identity
    const myId    = (crypto.randomUUID?.() ?? Math.random().toString(36).slice(2));
    const myHue   = Math.floor(Math.random()*360);
    const myColor = `hsl(${myHue} 85% 60%)`;
    const LS = { name:'cursor_name', show:'cursor_showMine', style:'cursor_pointy' };
    nick.value = localStorage.getItem(LS.name) || '';
    const myName = () => (nick.value.trim() || localStorage.getItem(LS.name) || `guest-${myId.slice(0,4)}`);
    nick.addEventListener('change', () => { localStorage.setItem(LS.name, nick.value.trim()); updatePresence(); });

    // Canvas sizing
    function resizeCanvas(){
      const r = board.getBoundingClientRect();
      const dpr = Math.max(1, devicePixelRatio || 1);
      canvas.width = Math.floor(r.width * dpr);
      canvas.height= Math.floor(r.height * dpr);
      canvas.style.width = r.width + 'px';
      canvas.style.height= r.height + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
      ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    }
    addEventListener('resize', resizeCanvas, {passive:true}); resizeCanvas();

    // Tools
    let mode = 'pointer';
    let brushColor = colorEl.value;
    let brushSize  = +sizeEl.value;
    colorEl.addEventListener('input', e => brushColor = e.target.value);
    sizeEl.addEventListener('input',  e => brushSize  = +e.target.value);
    function setMode(m){
      mode = m;
      [btnPointer,btnDraw,btnText].forEach(b=>b.classList.remove('on'));
      ({pointer:btnPointer, draw:btnDraw, text:btnText}[m]).classList.add('on');
    }
    btnPointer.onclick = () => setMode('pointer');
    btnDraw.onclick    = () => setMode('draw');
    btnText.onclick    = () => setMode('text');

    // Coords helpers
    function boardRect(){ return board.getBoundingClientRect(); }
    function normFromEvent(e){
      const r = boardRect();
      const x = (('touches' in e && e.touches[0]) ? e.touches[0].clientX : e.clientX);
      const y = (('touches' in e && e.touches[0]) ? e.touches[0].clientY : e.clientY);
      return { nx: (x - r.left) / r.width, ny: (y - r.top) / r.height };
    }
    function pxFromNorm(nx, ny){
      const r = boardRect(); return { x: nx * r.width, y: ny * r.height };
    }

    function lineTo(px, py, color, size){ ctx.strokeStyle=color; ctx.lineWidth=size; ctx.lineTo(px, py); ctx.stroke(); }
    function beginPath(px, py, color, size){ ctx.beginPath(); ctx.moveTo(px, py); ctx.strokeStyle=color; ctx.lineWidth=size; }

    // Text overlay
    function showTextbox(nx, ny, color, size){
      const {x,y} = pxFromNorm(nx, ny);
      const px = Math.max(12, size * 3.2);
      const box = document.createElement('textarea');
      box.className = 'textbox';
      box.style.left = (x|0)+'px'; box.style.top = (y|0)+'px';
      box.style.color = color; box.style.font = `bold ${px}px/1.2 ui-sans-serif,system-ui`;
      board.appendChild(box); box.focus();
      const commit = () => {
        const text = box.value.trim();
        if (text) { drawText(nx, ny, text, color, size); sendText(nx, ny, text, color, size); }
        box.remove();
      };
      box.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); commit(); } else if(e.key==='Escape'){ box.remove(); } });
      box.addEventListener('blur', commit, {once:true});
    }
    function drawText(nx, ny, text, color, size){
      const {x,y} = pxFromNorm(nx, ny);
      const px = Math.max(12, size * 3.2);
      ctx.save(); ctx.fillStyle = color; ctx.font = `bold ${px}px ui-sans-serif,system-ui`; ctx.textBaseline='top';
      text.split(/\n/).forEach((ln,i)=> ctx.fillText(ln, x, y + i*(px+4)));
      ctx.restore();
    }
    function clearCanvas(){ ctx.clearRect(0,0,canvas.width,canvas.height); }
    btnClear.onclick = () => { clearCanvas(); sendClear(); };

    // Supabase Realtime
    const sb = supabase.createClient(SUPABASE_URL, SUPABASE_ANON, { realtime:{ params:{ eventsPerSecond: 30 } } });
    const ch = sb.channel(roomName, { config:{ presence:{ key: myId } } });

    // Roster
    function renderRoster(state){
      const rows = [];
      for (const [id, metas] of Object.entries(state)){
        const u = metas[0]?.user || {};
        const name = u.name || 'guest'; const color = u.color || '#22d3ee';
        const you = (id === myId) ? ' you' : '';
        rows.push(`<div class="u${you?' you':''}">
          <span class="udot" style="background:${color}"></span>
          <span class="uname">${name}${you?' (you)':''}</span>
          <span class="ucolor">${color}</span>
        </div>`);
      }
      rosterList.innerHTML = rows.join('') || '<div class="muted">No one here yet.</div>';
    }

    // Remote cursors
    const peers = new Map();
    function mkCursor(id, color, name){
      const el = document.createElement('div');
      el.className = 'mcursor';
      el.style.setProperty('--c', color || '#22d3ee');
      el.innerHTML = `
        <div class="dot"></div>
        <svg class="arrow" viewBox="0 0 24 24">
          <path d="M2 2 L2 22 L10 14 L14 20 L18 18 L14 12 L22 12 Z" fill="currentColor"></path>
        </svg>
        <div class="tag">${name || 'guest'}</div>`;
      document.body.appendChild(el);
      peers.set(id, { el });
      return el;
    }
    function rmCursor(id){ const p=peers.get(id); if(p){ p.el.remove(); peers.delete(id); } }

    ch.on('presence', {event:'sync'}, () => {
      const state = ch.presenceState();
      renderRoster(state);
      for (const [id, metas] of Object.entries(state)){
        if (id === myId) continue;
        const u = metas[0]?.user || {};
        if (!peers.has(id)) mkCursor(id, u.color, u.name);
      }
      for (const id of peers.keys()) if (!state[id]) rmCursor(id);
    });

    // Separate drawing paths per remote user
    const remotePaths = new Map();
    function remoteBegin(id, x, y, color, size){
      beginPath(x,y,color,size);
      remotePaths.set(id, { open:true, last:{x,y}, color, size });
    }
    function remoteLine(id, x, y, color, size){
      const st = remotePaths.get(id);
      if (!st || !st.open){ remoteBegin(id, x, y, color, size); return; }
      lineTo(x,y,color,size);
      st.last = {x,y};
    }
    function remoteEnd(id){
      const st = remotePaths.get(id);
      if (st && st.open) ctx.closePath();
      remotePaths.delete(id);
    }

    ch.on('broadcast', {event:'cursor'}, ({ payload }) => {
      const { id, x, y, clicking, color, name } = payload;
      if (id === myId) return;
      const entry = peers.get(id) || mkCursor(id, color, name);
      entry.el.style.transform = `translate(${x*innerWidth}px, ${y*innerHeight}px)`;
      entry.el.classList.toggle('down', !!clicking);
    });

    ch.on('broadcast', {event:'draw'}, ({ payload }) => {
      const { from, kind, nx, ny, color, size } = payload;
      const {x,y} = pxFromNorm(nx, ny);
      if (kind==='begin') remoteBegin(from, x,y,color,size);
      else if (kind==='line') remoteLine(from, x,y,color,size);
      else if (kind==='end')  remoteEnd(from);
    });
    ch.on('broadcast', {event:'text'}, ({ payload }) => {
      const { nx, ny, text, color, size } = payload; drawText(nx,ny,text,color,size);
    });
    ch.on('broadcast', {event:'clear'}, () => clearCanvas());

    function updatePresence(){ ch.track({ user:{ id:myId, name:myName(), color:myColor } }); }
    ch.subscribe((status) => {
      stat.textContent = status.toLowerCase();
      dot.classList.toggle('ok', status === 'SUBSCRIBED');
      if (status === 'SUBSCRIBED') updatePresence();
    });

    // Show my cursor option
    let myCursorEl = null;
    function ensureMyCursor(){
      if (!myCursorEl){
        myCursorEl = document.createElement('div');
        myCursorEl.className = 'mcursor';
        myCursorEl.style.setProperty('--c', myColor);
        myCursorEl.innerHTML = `
          <div class="dot"></div>
          <svg class="arrow" viewBox="0 0 24 24">
            <path d="M2 2 L2 22 L10 14 L14 20 L18 18 L14 12 L22 12 Z" fill="currentColor"></path>
          </svg>
          <div class="tag">${myName()}</div>`;
        document.body.appendChild(myCursorEl);
      }
    }
    function moveMyCursor(px,py,down){
      if (!showMineEl.checked || !myCursorEl) return;
      myCursorEl.style.transform = `translate(${px}px, ${py}px)`;
      myCursorEl.classList.toggle('down', !!down);
    }
    showMineEl.checked = localStorage.getItem(LS.show) === '1';
    pointyEl.checked   = localStorage.getItem(LS.style) === '1';
    document.body.classList.toggle('pointy', pointyEl.checked);
    if (showMineEl.checked) ensureMyCursor();

    showMineEl.addEventListener('change', () => {
      localStorage.setItem(LS.show, showMineEl.checked ? '1' : '0');
      if (showMineEl.checked) ensureMyCursor();
      else if (myCursorEl){ myCursorEl.remove(); myCursorEl = null; }
    });
    pointyEl.addEventListener('change', () => {
      localStorage.setItem(LS.style, pointyEl.checked ? '1' : '0');
      document.body.classList.toggle('pointy', pointyEl.checked);
    });

    // Broadcast my cursor
    let cx=0, cy=0, last=0;
    function sendCursor(click=false){
      ch.send({ type:'broadcast', event:'cursor',
        payload:{ id:myId, x:cx, y:cy, clicking:click, name:myName(), color:myColor } });
    }
    addEventListener('mousemove', e => {
      cx = e.clientX / innerWidth; cy = e.clientY / innerHeight;
      const now = performance.now(); if (now-last>30){ last=now; sendCursor(false); }
      moveMyCursor(e.clientX, e.clientY, false);
    }, {passive:true});
    addEventListener('touchmove', e => {
      const t = e.touches[0]; if(!t) return;
      cx = t.clientX / innerWidth; cy = t.clientY / innerHeight;
      const now = performance.now(); if (now-last>30){ last=now; sendCursor(false); }
      moveMyCursor(t.clientX, t.clientY, false);
    }, {passive:true});
    addEventListener('mousedown', e => { sendCursor(true);  moveMyCursor(e.clientX, e.clientY, true);  }, {passive:true});
    addEventListener('mouseup',   e => { sendCursor(false); moveMyCursor(e.clientX, e.clientY, false); }, {passive:true});
    document.addEventListener('visibilitychange', () => { if (document.hidden) sendCursor(false); });

    // Local drawing (canvas only, so toolbar is clickable)
    let drawing=false, lastSentMove=0;
    function pointerDown(e){
      if (e.target !== canvas) return;
      if (e.button !== undefined && e.button !== 0) return;
      const {nx,ny} = normFromEvent(e);
      if (mode==='draw'){
        drawing = true;
        const p = pxFromNorm(nx,ny);
        beginPath(p.x,p.y,brushColor,brushSize);
        sendDraw('begin', nx, ny, brushColor, brushSize);
        e.preventDefault();
      } else if (mode==='text'){
        showTextbox(nx, ny, brushColor, brushSize);
        e.preventDefault();
      }
    }
    function pointerMove(e){
      if (!drawing || mode!=='draw') return;
      if (e.target !== canvas && e.type !== 'touchmove') return;
      const {nx,ny} = normFromEvent(e);
      const p = pxFromNorm(nx,ny);
      lineTo(p.x,p.y,brushColor,brushSize);
      const now = performance.now();
      if (now-lastSentMove>25){ lastSentMove=now; sendDraw('line', nx, ny, brushColor, brushSize); }
      e.preventDefault();
    }
    function pointerUp(e){
      if (drawing && mode==='draw'){
        ctx.closePath();
        const {nx,ny} = normFromEvent(e);
        sendDraw('end', nx, ny, brushColor, brushSize);
      }
      drawing=false; e.preventDefault();
    }
    canvas.addEventListener('mousedown',  pointerDown);
    canvas.addEventListener('mousemove',  pointerMove);
    addEventListener('mouseup',           pointerUp);
    canvas.addEventListener('touchstart', pointerDown, { passive:false });
    canvas.addEventListener('touchmove',  pointerMove, { passive:false });
    addEventListener('touchend',          pointerUp,   { passive:false });

    // Import from peers
    btnImport.onclick = () => {
      const rid = Math.random().toString(36).slice(2);
      ch.send({ type:'broadcast', event:'request_state', payload:{ rid } });
      let handled = false;
      ch.on('broadcast', {event:'state_png'}, ({ payload }) => {
        if (handled || payload.rid !== rid) return;
        handled = true;
        const img = new Image();
        img.onload = () => {
          const r = board.getBoundingClientRect();
          ctx.drawImage(img, 0, 0, r.width, r.height);
        };
        img.src = payload.png;
      });
    };
    ch.on('broadcast', {event:'request_state'}, ({ payload }) => {
      const r = board.getBoundingClientRect();
      const tmp = document.createElement('canvas');
      tmp.width = r.width; tmp.height = r.height;
      const tctx = tmp.getContext('2d');
      tctx.drawImage(canvas, 0, 0, r.width, r.height);
      const png = tmp.toDataURL('image/png');
      ch.send({ type:'broadcast', event:'state_png', payload:{ rid: payload.rid, png } });
    });

    // Send ops
    function sendDraw(kind, nx, ny, color, size){
      ch.send({ type:'broadcast', event:'draw', payload:{ from: myId, kind, nx, ny, color, size } });
    }
    function sendText(nx, ny, text, color, size){
      ch.send({ type:'broadcast', event:'text', payload:{ nx, ny, text, color, size } });
    }
    function sendClear(){
      ch.send({ type:'broadcast', event:'clear', payload:{} });
    }
  })();
  </script>
</body>
</html>
